{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "00276fb3-e947-4d92-a2c9-9fdb5083dd42",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.model_selection import train_test_split, GridSearchCV\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n",
    "\n",
    "# Load sales data\n",
    "sales_data = pd.read_csv('order-wise-item-sales (7)-1-Copy1.csv')\n",
    "\n",
    "# Load ingredient data set\n",
    "comparison_data_unique = pd.read_csv('book4.csv')\n",
    "\n",
    "# Adjust column names based on actual CSV column names\n",
    "sales_data.columns = sales_data.columns.str.strip().str.lower().str.replace(' ', '_')\n",
    "comparison_data_unique.columns = comparison_data_unique.columns.str.strip().str.lower().str.replace(' ', '_')\n",
    "\n",
    "# Standardize the case and strip whitespace from item names to ensure proper merging\n",
    "sales_data['itemname'] = sales_data['itemname'].str.strip().str.lower()\n",
    "comparison_data_unique['itemname'] = comparison_data_unique['itemname'].str.strip().str.lower()\n",
    "\n",
    "# Calculate total ingredient weight needed per ingredient\n",
    "sales_data['total_weight'] = sales_data['item_quantity'] * sales_data['item_total']\n",
    "merged_data = pd.merge(sales_data, comparison_data_unique, left_on='itemname', right_on='itemname', how='left')\n",
    "merged_data.drop(['order_date', 'order_time', 'order_id', 'reference_number', 'order_source',\n",
    "                  'sub_total', 'total_merchant_tax', 'total_tax', 'total_discount', 'net_payable',\n",
    "                  'item_total', 'item_discount', 'item_taxes'], axis=1, inplace=True)\n",
    "ingredient_totals = merged_data.groupby('ingredients')['total_weight'].sum().reset_index()\n",
    "\n",
    "# Set 'UNIT' to 'grams' for all rows\n",
    "ingredient_totals['unit'] = 'grams'\n",
    "\n",
    "# Rename columns to match the desired output\n",
    "ingredient_totals.rename(columns={'ingredients': 'INGREDIENTS', 'total_weight': 'Total Ingredient Weight'}, inplace=True)\n",
    "\n",
    "# Save the result to a new CSV file with specific formatting\n",
    "ingredient_totals[['INGREDIENTS', 'Total Ingredient Weight', 'unit']].to_csv('ingredients_needed.csv', index=False)\n",
    "\n",
    "# Display the result\n",
    "print(ingredient_totals[['INGREDIENTS', 'Total Ingredient Weight', 'unit']])\n",
    "\n",
    "# Save the result to a new CSV file\n",
    "ingredient_totals.to_csv('bingredients_needed.csv', index=False)\n",
    "\n",
    "# Load sales data\n",
    "sales_data = pd.read_csv('order-wise-item-sales (7)-1-Copy1.csv')\n",
    "\n",
    "# Load the new ingredient data\n",
    "ingredient_data = pd.read_csv('book4.csv')\n",
    "\n",
    "# Adjust column names based on actual CSV column names\n",
    "ingredient_data.columns = ingredient_data.columns.str.strip().str.lower().str.replace(' ', '_')\n",
    "\n",
    "# Ensure the column names are correctly formatted\n",
    "ingredient_data.rename(columns={\n",
    "    'itemname': 'ItemName',\n",
    "    'ingredients': 'INGREDIENTS',\n",
    "    'weightage': 'WEIGHTAGE',\n",
    "    'unit_price': 'UNIT_PRICE',\n",
    "    'cost': 'COST'\n",
    "}, inplace=True)\n",
    "\n",
    "# Convert WEIGHTAGE and COST to numeric, handle errors\n",
    "ingredient_data['WEIGHTAGE'] = pd.to_numeric(ingredient_data['WEIGHTAGE'], errors='coerce')\n",
    "ingredient_data['COST'] = pd.to_numeric(ingredient_data['COST'], errors='coerce')\n",
    "\n",
    "# Drop rows with NaN values in COST\n",
    "ingredient_data.dropna(subset=['COST'], inplace=True)\n",
    "\n",
    "# Convert weightage and cost to kilograms\n",
    "ingredient_data['WEIGHTAGE'] = ingredient_data['WEIGHTAGE'] / 1000\n",
    "ingredient_data['COST'] = ingredient_data['COST'] / 1000\n",
    "\n",
    "# Sales Data Analysis\n",
    "if 'ItemName' in sales_data.columns:\n",
    "    food_item_sales = sales_data.groupby('ItemName').agg({\n",
    "        'Item Quantity': 'sum',\n",
    "        'Sub Total': 'sum'\n",
    "    }).reset_index()\n",
    "\n",
    "    best_selling_by_quantity = food_item_sales.loc[food_item_sales['Item Quantity'].idxmax()]\n",
    "    best_selling_by_revenue = food_item_sales.loc[food_item_sales['Sub Total'].idxmax()]\n",
    "    average_quantity_sold = food_item_sales['Item Quantity'].mean()\n",
    "    average_revenue = food_item_sales['Sub Total'].mean()\n",
    "    top_3_least_selling_by_quantity = food_item_sales.nsmallest(3, 'Item Quantity')\n",
    "    top_3_least_selling_by_revenue = food_item_sales.nsmallest(3, 'Sub Total')\n",
    "\n",
    "        # Plotting sales data by quantity sold\n",
    "    plt.figure(figsize=(50, 50))\n",
    "    sns.barplot(x='Item Quantity', y='ItemName', data=food_item_sales, hue='ItemName', palette='Blues_r', dodge=False)\n",
    "    plt.xlabel('Quantity Sold')\n",
    "    plt.ylabel('Food Item')\n",
    "    plt.title('Quantity Sold of Food Items')\n",
    "    plt.grid(axis='x')\n",
    "    plt.legend('Plotting sales data by quantity sold')\n",
    "    plt.savefig('quantity_sold_plot.png', dpi=300, bbox_inches='tight')# Remove the legend to comply with the warning\n",
    "    plt.show()\n",
    "    \n",
    "    \n",
    "    # Plotting sales data by revenue generated\n",
    "    plt.figure(figsize=(50, 50))\n",
    "    sns.barplot(x='Sub Total', y='ItemName', data=food_item_sales, hue='ItemName', palette='Greens_r', dodge=False)\n",
    "    plt.xlabel('Revenue Generated')\n",
    "    plt.ylabel('Food Item')\n",
    "    plt.title('Revenue Generated by Food Items')\n",
    "    plt.grid(axis='x')\n",
    "    plt.legend('Plotting sales data by revenue generated') \n",
    "    plt.savefig('revenue_generated_plot.jpg', dpi=300, bbox_inches='tight')# Remove the legend to comply with the warning\n",
    "    plt.show()\n",
    "    \n",
    "\n",
    "\n",
    "    # Print metrics\n",
    "    print(\"Best Selling Food Item by Quantity Sold:\")\n",
    "    print(best_selling_by_quantity[['ItemName', 'Item Quantity']])\n",
    "    print(\"\\nBest Selling Food Item by Revenue:\")\n",
    "    print(best_selling_by_revenue[['ItemName', 'Sub Total']])\n",
    "    print(f\"\\nAverage Quantity Sold: {average_quantity_sold:.2f}\")\n",
    "    print(f\"Average Revenue: {average_revenue:.2f}\")\n",
    "    print(\"\\nTop 3 Least Selling Food Items by Quantity Sold:\")\n",
    "    print(top_3_least_selling_by_quantity[['ItemName', 'Item Quantity']])\n",
    "    print(\"\\nTop 3 Least Selling Food Items by Revenue:\")\n",
    "    print(top_3_least_selling_by_revenue[['ItemName', 'Sub Total']])\n",
    "\n",
    "    # Financial Summary\n",
    "    total_revenue = sales_data['Net Payable'].sum()\n",
    "    sales_data['Item Cost'] = sales_data['Item Total'] - sales_data['Item Discount'] + sales_data['Item Taxes']\n",
    "    total_expenses = sales_data['Item Cost'].sum()\n",
    "    total_profit = total_revenue - total_expenses\n",
    "\n",
    "    print(f\"\\nFinancial Summary:\")\n",
    "    print(f\"-----------------\")\n",
    "    print(f\"Total Revenue: ₹{total_revenue:.2f}\")\n",
    "    print(f\"Total Expenses: ₹{total_expenses:.2f}\")\n",
    "    print(f\"Total Profit: ₹{total_profit:.2f}\")\n",
    "\n",
    "    # Loss Analysis for Top 3 Least Selling Items\n",
    "    usd_to_inr_rate = 75.0\n",
    "    top_3_least_selling_items = top_3_least_selling_by_quantity['ItemName'].tolist()\n",
    "    ingredients_of_least_selling_items = ingredient_data[ingredient_data['ItemName'].isin(top_3_least_selling_items)]\n",
    "\n",
    "    loss_data = sales_data[sales_data['ItemName'].isin(top_3_least_selling_items)].copy()\n",
    "    loss_data['Loss INR'] = loss_data['Sub Total'] * usd_to_inr_rate\n",
    "    total_loss_top_3 = loss_data['Loss INR'].sum()\n",
    "\n",
    "    print(\"\\nIngredients and Financial Impact:\")\n",
    "    for item_name in top_3_least_selling_items:\n",
    "        ingredients_used = ingredients_of_least_selling_items[ingredients_of_least_selling_items['ItemName'] == item_name]\n",
    "        total_quantity_sold = loss_data[loss_data['ItemName'] == item_name]['Item Quantity'].sum()\n",
    "        total_loss = loss_data[loss_data['ItemName'] == item_name]['Loss INR'].sum()\n",
    "\n",
    "        print(f\"\\nFood Item: {item_name}\")\n",
    "        print(\"Ingredients:\")\n",
    "        for index, row in ingredients_used.iterrows():\n",
    "            print(f\"- {row['INGREDIENTS']}: {row['WEIGHTAGE']} kilograms\")\n",
    "        print(f\"\\nTotal Quantity Sold: {total_quantity_sold}\")\n",
    "        print(f\"Total Loss (Estimated) in INR: ₹{total_loss:.2f}\")\n",
    "        print(\"Suggestions:\")\n",
    "        print(\"- Analyze customer feedback and preferences\")\n",
    "        print(\"- Consider modifying the recipe or presentation\")\n",
    "        print(\"- Evaluate pricing strategy and promotions\")\n",
    "\n",
    "    print(f\"\\nTotal Loss Caused by Top 3 Least Selling Items: ₹{total_loss_top_3:.2f}\")\n",
    "\n",
    "    # Ingredient Weight Calculation and merge\n",
    "    sales_data['Total Weight'] = sales_data['Item Quantity'] * sales_data['Item Total']\n",
    "    merged_data = pd.merge(sales_data, ingredient_data, on='ItemName', how='left')\n",
    "    merged_data.drop(['Order Date', 'Order Time', 'Order Id', 'Reference Number', 'Order Source',\n",
    "                      'Sub Total', 'Total Merchant Tax', 'Total Tax', 'Total Discount', 'Net Payable',\n",
    "                      'Item Total', 'Item Discount', 'Item Taxes'], axis=1, inplace=True)\n",
    "    ingredient_totals = merged_data.groupby('INGREDIENTS')['Total Weight'].sum().reset_index()\n",
    "    ingredient_totals['Unit'] = 'kilograms'\n",
    "    ingredient_totals.rename(columns={'INGREDIENTS': 'INGREDIENTS', 'Total Weight': 'Total Ingredient Weight'}, inplace=True)\n",
    "    ingredient_totals.to_csv('ingredients_needed.csv', index=False)\n",
    "    print(ingredient_totals)\n",
    "\n",
    "    # Predicting Ingredient Weight using Random Forest\n",
    "    X = ingredient_data[['WEIGHTAGE']]\n",
    "    y = ingredient_data['COST']\n",
    "    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
    "\n",
    "    model_pipeline = Pipeline([\n",
    "        ('scaler', StandardScaler()),\n",
    "        ('regressor', RandomForestRegressor(random_state=42))\n",
    "    ])\n",
    "\n",
    "    param_grid = {\n",
    "        'regressor__n_estimators': [100, 150, 200],\n",
    "        'regressor__max_depth': [None, 10, 20],\n",
    "        'regressor__min_samples_split': [2, 5],\n",
    "        'regressor__min_samples_leaf': [1, 2]\n",
    "    }\n",
    "\n",
    "    grid_search = GridSearchCV(model_pipeline, param_grid, cv=5, scoring='neg_mean_squared_error', verbose=1)\n",
    "    grid_search.fit(X_train, y_train)\n",
    "\n",
    "    best_params = grid_search.best_params_\n",
    "    best_score = grid_search.best_score_\n",
    "\n",
    "    print(\"Best Parameters:\", best_params)\n",
    "    print(\"Best Score (Negative MSE):\", best_score)\n",
    "\n",
    "    y_pred = grid_search.predict(X_test)\n",
    "    mae = mean_absolute_error(y_test, y_pred)\n",
    "    mse = mean_squared_error(y_test, y_pred)\n",
    "    rmse = np.sqrt(mse)\n",
    "    r2 = r2_score(y_test, y_pred)\n",
    "\n",
    "    print(\"\\nEvaluation Metrics:\")\n",
    "    print(f\"Mean Absolute Error (MAE): {mae:.2f} kilograms\")\n",
    "    print(f\"Mean Squared Error (MSE): {mse:.2f} kilograms^2\")\n",
    "    print(f\"Root Mean Squared Error (RMSE): {rmse:.2f} kilograms\")\n",
    "    print(f\"R-squared (R2): {r2:.2f}\")\n",
    "\n",
    "    y_test_mean = y_test.mean()\n",
    "    accuracy = 1 - (mse / y_test_mean)\n",
    "    print(f\"Accuracy: {accuracy:.2%}\")\n",
    "    # Plotting\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    sns.histplot(y_test, color='blue', label='Actual', kde=True)\n",
    "    sns.histplot(y_pred, color='red', label='Predicted', kde=True)\n",
    "    plt.title('Distribution of Actual vs Predicted Values')\n",
    "    plt.xlabel('Total Ingredient Weight (kg)')\n",
    "    plt.ylabel('Count')\n",
    "    plt.legend()\n",
    "    plt.grid(True)\n",
    "    plt.savefig('actual_vs_predicted_histogram.png', dpi=300, bbox_inches='tight')\n",
    "    plt.show()\n",
    "    \n",
    "    plt.figure(figsize=(8, 8))\n",
    "    plt.scatter(y_test, y_pred, color='blue', alpha=0.7)\n",
    "    plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], linestyle='--', color='red')\n",
    "    plt.title('Actual vs Predicted Values')\n",
    "    plt.xlabel('Actual Total Ingredient Weight (kg)')\n",
    "    plt.ylabel('Predicted Total Ingredient Weight (kg)')\n",
    "    plt.grid(True)\n",
    "    plt.savefig('actual_vs_predicted_scatter.jpg', dpi=300, bbox_inches='tight')\n",
    "    plt.show()\n",
    "\n",
    "    \n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
